<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Candlestick Chart</title>
    <!-- å¼•å…¥ Chart.js å’Œé‡‘èå›¾è¡¨æ’ä»¶ -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <!-- åœ¨ head åŒºåŸŸå¼•å…¥ annotation æ’ä»¶ -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0"></script>

    <style>
        /* ç¾åŒ–ä¸‹æ‹‰æ¡†å’Œæ•´ä½“å¸ƒå±€ */
        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
            padding: 12px;
            background: #f5f5f5;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        label {
            font-weight: 600;
            color: #555;
        }

        select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 14px;
            transition: all 0.3s;
        }

        select:hover {
            border-color: #aaa;
        }

        select:focus {
            outline: none;
            border-color: #4285f4;
            box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
        }

        /* æ¨ªçº¿æ ·å¼ */
        #horizontal-line {
            position: absolute;
            display: none;
            border-top: 1px dashed #999;
            pointer-events: none;
        }

        /* ä»·æ ¼æ ‡ç­¾æ ·å¼ */
        #price-label {
            position: absolute;
            display: none;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
<!-- ä¸‹æ‹‰é€‰æ‹©æ¡† -->
<div class="controls">
    <div class="control-group">
        <label for="symbol">Symbol:</label>
        <select id="symbol">
            <option value="BTCUSDT" selected>BTC/USDT</option>
            <option value="ETHUSDT">ETH/USDT</option>
            <option value="SUIUSDT">SUI/USDT</option>
            <option value="EPTUSDT">EPT/USDT</option>
        </select>
    </div>

    <div class="control-group">
        <label for="interval">Interval:</label>
        <select id="interval">
            <option value="1m">1åˆ†é’Ÿ</option>
            <option value="5m" selected>5åˆ†é’Ÿ</option>
            <option value="15m">15åˆ†é’Ÿ</option>
            <option value="1h">1å°æ—¶</option>
            <option value="4h">4å°æ—¶</option>
            <option value="1d">1å¤©</option>
        </select>
    </div>

    <div class="control-group">
        <label for="limit">æ•°æ®é‡:</label>
        <select id="limit">
            <option value="30">30æ¡</option>
            <option value="50" selected>50æ¡</option>
            <option value="100">100æ¡</option>
        </select>
    </div>
</div>

<!-- å›¾è¡¨å®¹å™¨ -->
<div style="position: relative; width: 1920px; height: 1080px;">
    <canvas id="candlestickChart"></canvas>
    <div id="horizontal-line"></div>
    <div id="price-label"></div>
</div>

<script>
    let chart;

    function getChartParams() {
        return {
            symbol: document.getElementById("symbol").value || "BTCUSDT",
            interval: document.getElementById("interval").value || "5m",
            limit: document.getElementById("limit").value || "50"
        };
    }

    async function fetchCandlestickData(startTime = null, endTime = null) {
        const {symbol, interval, limit} = getChartParams();
        let url = `/api/candlesticks?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        if (startTime) url += `&startTime=${startTime}`;
        if (endTime) url += `&endTime=${endTime}`;

        const response = await fetch(url);
        const data = await response.json();

        return data.map(candle => ({
            x: new Date(candle.time).getTime(),
            o: candle.open,
            h: candle.high,
            l: candle.low,
            c: candle.close,
            v: candle.volume,
            qv: candle.quoteAssetVolume,
            nt: candle.numberOfTrades,
            ch: candle.change,
            am: candle.amplitude
        })).sort((a, b) => a.x - b.x);
    }

    async function renderChart() {
        const ctx = document.getElementById('candlestickChart').getContext('2d');
        const candlestickData = await fetchCandlestickData();

        if (chart) {
            chart.data.datasets[0].data = candlestickData;
            chart.update();
            return;
        }

        chart = new Chart(ctx, {
            type: 'candlestick',
            data: {
                datasets: [{
                    label: `${getChartParams().symbol}`,
                    data: candlestickData,
                    // è®¾ç½®èœ¡çƒ›é¢œè‰²
                    color: {
                        up: '#ff2c2c',    // æ­£çº¢
                        down: '#00c42a',  // æ­£ç»¿
                        unchanged: '#888888'
                    },
                    borderColor: {
                        up: '#ff2c2c',
                        down: '#00c42a',
                        unchanged: '#888888'
                    },
                    borderWidth: 1,
                    barPercentage: 1.0,
                    categoryPercentage: 1.0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: {duration: 0},
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: getChartParams().interval === '1d' ? 'day' :
                                getChartParams().interval === '4h' ? 'hour' : 'minute',
                            displayFormats: {
                                minute: 'HH:mm',
                                hour: 'MM-dd HH:mm',
                                day: 'yyyy-MM-dd'
                            },
                            tooltipFormat: 'yyyy-MM-dd HH:mm:ss',
                            stepSize: 1
                        },
                        ticks: {
                            source: 'data',
                            autoSkip: false,
                            maxRotation: 0,
                            minRotation: 0
                        },
                        grid: {display: false},
                        offset: false,
                        bounds: 'data',
                        title: {display: true, text: 'Time'}
                    },
                    y: {
                        ticks: {
                            callback: function (value) {
                                return value.toFixed(4);
                            }
                        },
                        title: {display: true, text: 'Price'}
                    }
                },
                plugins: {
                    legend: {display: false},
                    tooltip: {
                        enabled: true,
                        callbacks: {
                            label: function (context) {
                                const data = context.raw;
                                return [
                                    `å¼€: ${data.o}`,
                                    `é«˜: ${data.h}`,
                                    `ä½: ${data.l}`,
                                    `æ”¶: ${data.c}`,
                                    `æˆäº¤é‡: ${data.v}`,
                                    `æˆäº¤é¢: ${data.qv}`,
                                    `æˆäº¤ç¬”æ•°: ${data.nt}`,
                                    `æ¶¨è·Œå¹…: ${parseFloat(data.ch) >= 0 ? 'ğŸŸ¢' : 'ğŸ”´'} ${data.ch}`,
                                    `éœ‡å¹…: ${data.am}`
                                ];
                            }
                        }
                    }
                }
            }
        });
    }

    // åˆå§‹åŒ–å›¾è¡¨
    renderChart();

    // ç›‘å¬ä¸‹æ‹‰æ¡†å˜åŒ–
    document.querySelectorAll('select').forEach(select => {
        select.addEventListener('change', () => {
            renderChart();
        });
    });

    // è·å– DOM å…ƒç´ 
    const canvas = document.getElementById('candlestickChart');
    const horizontalLine = document.getElementById('horizontal-line');
    const priceLabel = document.getElementById('price-label');

    let chartArea = null;

    function getChartArea() {
        if (!chart) return null;
        const area = chart.chartArea;
        return {
            top: chart.scales.y.top,
            bottom: chart.scales.y.bottom,
            left: chart.scales.x.left,
            right: chart.scales.x.right
        };
    }

    function getYValueFromPixel(y) {
        const scaleY = chart.scales.y;
        return scaleY.getValueForPixel(y);
    }

    function updateCrosshair(x, y) {
        chartArea = getChartArea();
        if (!chartArea || y < chartArea.top || y > chartArea.bottom) {
            horizontalLine.style.display = 'none';
            priceLabel.style.display = 'none';
            return;
        }

        horizontalLine.style.top = `${y}px`;
        horizontalLine.style.left = `${chartArea.left}px`;
        horizontalLine.style.width = `${chartArea.right - chartArea.left}px`;
        horizontalLine.style.display = 'block';

        const price = getYValueFromPixel(y).toFixed(4);
        priceLabel.innerHTML = `$${price}`;
        priceLabel.style.left = `${x + 10}px`;
        priceLabel.style.top = `${y - 20}px`;
        priceLabel.style.display = 'block';
        priceLabel.dataset.price = price;
    }

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        updateCrosshair(x, y);
    });

    canvas.addEventListener('mouseleave', () => {
        horizontalLine.style.display = 'none';
        priceLabel.style.display = 'none';
    });

    // canvas.addEventListener('click', () => {
    //     if (priceLabel.style.display === 'none') return;
    //
    //     const price = priceLabel.dataset.price;
    //     const symbol = document.getElementById("symbol").value;
    //
    //     const confirmCreate = confirm(`æ‚¨ç‚¹å‡»çš„ä»·æ ¼ä¸ºï¼š${price}\næ˜¯å¦è®¾ç½®ä»·æ ¼æé†’ï¼Ÿ`);
    //     if (confirmCreate) {
    //         const threshold = prompt("è¯·è¾“å…¥æé†’é˜ˆå€¼:", price);
    //
    //         if (threshold !== null && !isNaN(threshold)) {
    //             fetch(`/api/reminder/${symbol}?threshold=${threshold}`, {
    //                 method: 'GET'
    //             }).then(response => {
    //                 if (response.ok) {
    //                     alert("æé†’ä»»åŠ¡å·²æäº¤ï¼");
    //                 } else {
    //                     alert("æäº¤å¤±è´¥ï¼Œè¯·ç¨åå†è¯•ã€‚");
    //                 }
    //             }).catch(error => {
    //                 console.error('Error:', error);
    //                 alert("ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥è¿æ¥ã€‚");
    //             });
    //         }
    //     }
    // });


    // å³é”®èœå• DOM
    const customMenu = document.createElement('div');
    customMenu.id = 'custom-context-menu';
    customMenu.style.position = 'absolute';
    customMenu.style.display = 'none';
    customMenu.style.background = '#fff';
    customMenu.style.border = '1px solid #ccc';
    customMenu.style.borderRadius = '4px';
    customMenu.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
    customMenu.style.zIndex = 1000;
    customMenu.innerHTML = `
  <div id="set-reminder" style="padding:8px 16px;cursor:pointer;">è®¾ç½®ä»·æ ¼æé†’</div>
   <div id="draw-redline" style="padding:8px 16px;cursor:pointer;">åˆ’çº¢çº¿</div>
  <div id="long-action" style="padding:8px 16px;cursor:pointer;">åšå¤š</div>
  <div id="short-action" style="padding:8px 16px;cursor:pointer;">åšç©º</div>
`;
    document.body.appendChild(customMenu);

    let rightClickPrice = null;

    // å³é”®äº‹ä»¶
    canvas.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        updateCrosshair(x, y);

        // è®°å½•å½“å‰ä»·æ ¼
        rightClickPrice = priceLabel.dataset.price;

        // æ˜¾ç¤ºè‡ªå®šä¹‰èœå•
        customMenu.style.left = `${e.pageX}px`;
        customMenu.style.top = `${e.pageY}px`;
        customMenu.style.display = 'block';
    });

    // ç‚¹å‡»èœå•é¡¹
    document.getElementById('set-reminder').onclick = function () {
        customMenu.style.display = 'none';
        if (!rightClickPrice) return;
        const symbol = document.getElementById("symbol").value;
        const threshold = prompt("è¯·è¾“å…¥æé†’é˜ˆå€¼:", rightClickPrice);
        if (threshold !== null && !isNaN(threshold)) {
            fetch(`/api/reminder/${symbol}?threshold=${threshold}`, {
                method: 'GET'
            }).then(response => {
                if (response.ok) {
                    alert("æé†’ä»»åŠ¡å·²æäº¤ï¼");
                } else {
                    alert("æäº¤å¤±è´¥ï¼Œè¯·ç¨åå†è¯•ã€‚");
                }
            }).catch(error => {
                alert("ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥è¿æ¥ã€‚");
            });
        }
    };


    let reminderLine = null;

    // ç»˜åˆ¶æé†’çº¿
    function drawReminderLine(price) {
        reminderLine = parseFloat(price);
        chart.options.plugins.annotation = {
            type: 'line',
            yMin: reminderLine,
            yMax: reminderLine,
            borderColor: '#2196f3',
            borderWidth: 2,
            borderDash: [6, 6],
            label: {
                enabled: true,
                content: `æé†’ä»·: ${reminderLine.toFixed(4)}`,
                position: 'end',
                backgroundColor: '#2196f3',
                color: 'white'
            }
        };
        chart.update();
    }

    // è®¾ç½®æé†’æ—¶è°ƒç”¨
    document.getElementById('set-reminder').onclick = function () {
        customMenu.style.display = 'none';
        if (!rightClickPrice) return;
        const symbol = document.getElementById("symbol").value;
        const threshold = prompt("è¯·è¾“å…¥æé†’é˜ˆå€¼:", rightClickPrice);
        if (threshold !== null && !isNaN(threshold)) {
            drawReminderLine(threshold); // ç”»çº¿
            fetch(`/api/reminder/${symbol}?threshold=${threshold}`, {
                method: 'GET'
            }).then(response => {
                if (response.ok) {
                    alert("æé†’ä»»åŠ¡å·²æäº¤ï¼");
                } else {
                    alert("æäº¤å¤±è´¥ï¼Œè¯·ç¨åå†è¯•ã€‚");
                }
            }).catch(error => {
                alert("ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥è¿æ¥ã€‚");
            });
        }
    };


    // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
    document.addEventListener('click', () => {
        customMenu.style.display = 'none';
    });


    // 2. ç»˜åˆ¶æ°´å¹³çº¿çš„å‡½æ•°
    function drawProfitLossLines(basePrice, type) {
        basePrice = parseFloat(basePrice);
        let profit, loss;
        if (type === 'long') {
            profit = basePrice * 1.015;
            loss = basePrice * 0.99;
        } else {
            profit = basePrice * 0.985;
            loss = basePrice * 1.01;
        }
        chart.options.plugins.annotation = {
            annotations: {
                // ç›ˆåˆ©åŒºé—´èƒŒæ™¯ï¼ˆæ·¡ç»¿è‰²ï¼‰
                profitBox: {
                    type: 'box',
                    yMin: Math.min(basePrice, profit),
                    yMax: Math.max(basePrice, profit),
                    backgroundColor: 'rgba(0,196,42,0.12)', // æ·¡ç»¿è‰²
                    borderWidth: 0
                },
                // æŸå¤±åŒºé—´èƒŒæ™¯ï¼ˆæ·¡çº¢è‰²ï¼‰
                lossBox: {
                    type: 'box',
                    yMin: Math.min(basePrice, loss),
                    yMax: Math.max(basePrice, loss),
                    backgroundColor: 'rgba(255,44,44,0.12)', // æ·¡çº¢è‰²
                    borderWidth: 0
                },
                entryLine: {
                    type: 'line',
                    yMin: basePrice,
                    yMax: basePrice,
                    borderColor: 'black',
                    borderWidth: 0.5,
                    borderDash: [8, 6],
                    label: {
                        enabled: true,
                        content: `å¼€ä»“ä»·: ${basePrice.toFixed(4)}`,
                        position: 'end',
                        backgroundColor: 'black',
                        color: 'white'
                    }
                },
                profitLine: {
                    type: 'line',
                    yMin: profit,
                    yMax: profit,
                    borderColor: 'green',
                    borderWidth: 0.5,
                    borderDash: [8, 6],
                    label: {
                        enabled: true,
                        content: `ç›ˆåˆ©çº¿: ${profit.toFixed(4)}`,
                        position: 'end',
                        backgroundColor: 'green',
                        color: 'white'
                    }
                },
                lossLine: {
                    type: 'line',
                    yMin: loss,
                    yMax: loss,
                    borderColor: 'red',
                    borderWidth: 0.5,
                    borderDash: [8, 6],
                    label: {
                        enabled: true,
                        content: `æ­¢æŸçº¿: ${loss.toFixed(4)}`,
                        position: 'end',
                        backgroundColor: 'red',
                        color: 'white'
                    }
                }
            }
        };
        chart.update();
    }

    // 3. ç»‘å®šäº‹ä»¶
    document.getElementById('long-action').onclick = function () {
        customMenu.style.display = 'none';
        if (!rightClickPrice) return;
        drawProfitLossLines(rightClickPrice, 'long');
    };
    document.getElementById('short-action').onclick = function () {
        customMenu.style.display = 'none';
        if (!rightClickPrice) return;
        drawProfitLossLines(rightClickPrice, 'short');
    };


    let isDraggingEntryLine = false;

    // åˆ¤æ–­é¼ æ ‡æ˜¯å¦ç‚¹åœ¨å¼€ä»“ä»·çº¿ä¸Š
    function isOnEntryLine(mouseY) {
        if (!chart || !chart.options.plugins.annotation?.annotations?.entryLine) return false;
        const entryPrice = chart.options.plugins.annotation.annotations.entryLine.yMin;
        const scaleY = chart.scales.y;
        const entryY = scaleY.getPixelForValue(entryPrice);
        return Math.abs(mouseY - entryY) < 8; // 8åƒç´ å®¹å·®
    }

    // ç›‘å¬ mousedown
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const y = e.clientY - rect.top;
        if (isOnEntryLine(y)) {
            isDraggingEntryLine = true;
            document.body.style.cursor = 'ns-resize';
        }
    });

    // ç›‘å¬ mousemove
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const y = e.clientY - rect.top;
        if (isDraggingEntryLine) {
            const newPrice = getYValueFromPixel(y);
            rightClickPrice = newPrice.toFixed(4);
            // è¿™é‡Œå‡è®¾ä¸Šæ¬¡æ˜¯åšå¤šè¿˜æ˜¯åšç©ºå¯ç”¨å˜é‡ä¿å­˜ï¼Œä¾‹ï¼šlastActionType
            drawProfitLossLines(rightClickPrice, window.lastActionType || 'long');
        }
    });

    // ç›‘å¬ mouseup
    canvas.addEventListener('mouseup', () => {
        if (isDraggingEntryLine) {
            isDraggingEntryLine = false;
            document.body.style.cursor = 'default';
        }
    });

    // åœ¨åšå¤š/åšç©ºæ—¶è®°å½•ç±»å‹
    document.getElementById('long-action').onclick = function () {
        customMenu.style.display = 'none';
        if (!rightClickPrice) return;
        window.lastActionType = 'long';
        drawProfitLossLines(rightClickPrice, 'long');
    };
    document.getElementById('short-action').onclick = function () {
        customMenu.style.display = 'none';
        if (!rightClickPrice) return;
        window.lastActionType = 'short';
        drawProfitLossLines(rightClickPrice, 'short');
    };

    // 2. çº¢çº¿é›†åˆ
    let redLines = [];

    // 3. åˆ’çº¢çº¿å‡½æ•°
    function drawRedLine(price) {
        if (!chart.options.plugins.annotation) chart.options.plugins.annotation = {};
        if (!chart.options.plugins.annotation.annotations) chart.options.plugins.annotation.annotations = {};
        // ç”¨æ—¶é—´æˆ³åšå”¯ä¸€ key
        const id = 'redLine_' + Date.now();
        chart.options.plugins.annotation.annotations[id] = {
            type: 'line',
            yMin: parseFloat(price),
            yMax: parseFloat(price),
            borderColor: 'red',
            borderWidth: 1,
            borderDash: [8, 6],
            label: {
                enabled: true,
                content: `çº¢çº¿: ${parseFloat(price).toFixed(4)}`,
                position: 'end',
                backgroundColor: 'red',
                color: 'white'
            }
        };
        redLines.push(id);
        chart.update();
    }

    // 4. ç»‘å®šèœå•äº‹ä»¶
    document.getElementById('draw-redline').onclick = function () {
        customMenu.style.display = 'none';
        if (!rightClickPrice) return;
        drawRedLine(rightClickPrice);
    };


</script>
</body>
</html>
